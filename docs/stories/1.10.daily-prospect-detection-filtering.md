<!-- Powered by BMAD™ Core -->

# Story 1.10: Daily Prospect Detection & Filtering

## Status
Draft

## Story
**As a** user,
**I want** 20 ultra-qualified prospects per day (max 40) to be automatically detected at 6 AM based on my ICP and Persona criteria,
**so that** I can start each day with a fresh, targeted prospect list without manual searching.

## Dependencies
- **Story 1.2.1** (Migration PhantomBuster → UniPil) MUST be completed - UniPilService available for LinkedIn search
- **Story 1.2** (LinkedIn Profile Scraping Workflow) MUST be completed - Prospect scraping logic and storage
- **Story 1.9** (LinkedIn Warm-up Workflow) MUST be completed - Warm-up schedule table and workflow integration
- **Story 1.11** (Settings Management API) MUST be completed - ICP configuration storage and retrieval

## Acceptance Criteria
1. Daily detection schedule: System runs prospect detection workflow daily at 6 AM (configurable time)
2. ICP + Persona matching: System uses UniPil API to search LinkedIn profiles matching user's ICP criteria (industries, job titles, company sizes, locations) and Persona criteria (multiple personas supported)
3. Prospect count: System detects exactly 20 prospects per day (configurable, max 40)
4. Exclusion logic: System excludes prospects already contacted by user (checked against `prospects` table with status = 'contacted', 'engaged', 'qualified', 'booked')
5. Exclusion logic extended: System excludes prospects with existing entries in `linkedin_warmup_schedule` or `linkedin_connections` tables
6. Autopilot mode: User can enable full autopilot mode where prospects are automatically added and warm-up starts without validation
7. Semi-auto mode: User can enable semi-auto mode where prospects are queued for validation before warm-up starts
8. Prospect storage: Detected prospects are stored in `prospects` table with status = 'new' (if autopilot) or 'pending_validation' (if semi-auto)
9. Notification: User receives notification (email or in-app) with daily prospect list and option to validate (if semi-auto mode)
10. Multi-tenant isolation: All prospects scoped to user_id with RLS policies

## Tasks / Subtasks

- [ ] **Task 1: Create N8N workflow for daily prospect detection** (AC: 1, 2, 3, 4, 5, 8)
  - [ ] **Prerequisites:** Story 1.2.1, 1.2, 1.9, 1.11 must be completed
  - [ ] Create `workflows/daily-prospect-detection.json` workflow file
  - [ ] Add Schedule Trigger node:
    - Cron expression: `0 6 * * *` (runs daily at 6 AM UTC, configurable per user)
    - Or use user-configured time from `users.detection_time` field
  - [ ] Add Function node to get all active users:
    - Query: `SELECT id, detection_mode, daily_prospect_count, detection_time, icp_criteria FROM users WHERE onboarding_completed = TRUE`
    - Filter active users (can add subscription check if needed)
  - [ ] Add Loop node to process each user:
    - Use N8N "Split In Batches" node or "For Each" node
    - Process users sequentially to respect rate limits
  - [ ] For each user, query ICP + Persona configuration:
    - **Note:** ICP config stored in `users.icp_criteria` JSONB field (not separate table)
    - Query: `SELECT icp_criteria FROM users WHERE id = $user_id`
    - Parse JSONB: `icp_criteria` structure: `{ industry: string[], job_titles: string[], company_size: string[], location: string[], exclusions?: string[] }`
    - **Note:** Persona criteria may be in separate JSONB field or within `icp_criteria` (confirm structure)
  - [ ] Add UniPil API integration node for LinkedIn profile search:
    - Use HTTP Request node or UniPilService (if available via API Gateway)
    - Endpoint: `POST {{ $env.UNIPIL_API_URL }}/api/v1/linkedin/search` (confirm exact endpoint)
    - Headers: `Authorization: Bearer {{ $env.UNIPIL_API_KEY }}`
    - Request body: Map ICP criteria to UniPil format:
      ```json
      {
        "industry": ["Technology", "SaaS"],
        "job_titles": ["CTO", "VP Engineering"],
        "company_size": "50-200",
        "location": "US",
        "limit": 20
      }
      ```
    - **Note:** Use `users.daily_prospect_count` or default 20, max 40
  - [ ] Limit results to configured count:
    - Use `daily_prospect_count` from user settings (default 20, max 40)
    - UniPil API may return more results, limit to `daily_prospect_count` in N8N workflow
  - [ ] Add exclusion logic - Query contacted prospects:
    - Query: `SELECT linkedin_url FROM prospects WHERE user_id = $user_id AND status IN ('contacted', 'engaged', 'qualified', 'booked')`
    - Create array of excluded LinkedIn URLs: `excluded_urls = []`
  - [ ] Add exclusion logic - Query warm-up schedule:
    - Query: `SELECT DISTINCT p.linkedin_url FROM linkedin_warmup_schedule lws JOIN prospects p ON lws.prospect_id = p.id WHERE lws.user_id = $user_id`
    - Add to `excluded_urls` array
  - [ ] Add exclusion logic - Query connection requests (if `linkedin_connections` table exists):
    - Query: `SELECT DISTINCT p.linkedin_url FROM linkedin_connections lc JOIN prospects p ON lc.prospect_id = p.id WHERE lc.user_id = $user_id`
    - Add to `excluded_urls` array
    - **Note:** If table doesn't exist, skip this step (Story 1.9 may create it)
  - [ ] Filter out excluded prospects from UniPil results:
    - Use N8N Function node or Filter node
    - Filter: `excluded_urls.includes(prospect.linkedin_url) === false`
    - Keep only prospects not in exclusion list
  - [ ] Store new prospects in `prospects` table:
    - Determine status based on user mode:
      - Autopilot: `status = 'new'`
      - Semi-auto: `status = 'pending_validation'`
    - Insert: `INSERT INTO prospects (user_id, campaign_id, full_name, job_title, company_name, linkedin_url, location, profile_summary, status, source) VALUES (...)`
    - Set `source = 'daily_detection'`
    - Set `campaign_id = NULL` (or link to active campaign if exists)

- [ ] **Task 2: Implement exclusion service in API Gateway** (AC: 4, 5)
  - [ ] Create `apps/api/src/services/ExclusionService.ts`
  - [ ] Implement `getExcludedProspectIds(userId)`:
    - Input: `userId: string`
    - Return: `Promise<string[]>` (array of LinkedIn URLs to exclude)
  - [ ] Query contacted prospects:
    - Query: `SELECT linkedin_url FROM prospects WHERE user_id = $userId AND status IN ('contacted', 'engaged', 'qualified', 'booked', 'meeting_booked') AND linkedin_url IS NOT NULL`
    - Extract LinkedIn URLs: `contacted_urls = []`
  - [ ] Query warm-up schedule (if table exists):
    - Query: `SELECT DISTINCT p.linkedin_url FROM linkedin_warmup_schedule lws JOIN prospects p ON lws.prospect_id = p.id WHERE lws.user_id = $userId AND p.linkedin_url IS NOT NULL`
    - Extract LinkedIn URLs: `warmup_urls = []`
  - [ ] Query connection requests (if `linkedin_connections` table exists):
    - Query: `SELECT DISTINCT p.linkedin_url FROM linkedin_connections lc JOIN prospects p ON lc.prospect_id = p.id WHERE lc.user_id = $userId AND p.linkedin_url IS NOT NULL`
    - Extract LinkedIn URLs: `connection_urls = []`
    - **Note:** If table doesn't exist, return empty array
  - [ ] Combine all exclusions:
    - Merge arrays: `excluded_urls = [...contacted_urls, ...warmup_urls, ...connection_urls]`
    - Remove duplicates: `excluded_urls = [...new Set(excluded_urls)]`
    - Return: `excluded_urls`
  - [ ] Add caching (Upstash Redis):
    - Cache key: `excluded_prospects:{userId}:{YYYY-MM-DD}`
    - Cache TTL: 24 hours
    - Check cache first: `GET excluded_prospects:{userId}:{YYYY-MM-DD}`
    - If cache miss, query database and store: `SET excluded_prospects:{userId}:{YYYY-MM-DD} $excluded_urls EX 86400`
    - Return cached or fresh data

- [ ] **Task 3: Create user mode configuration** (AC: 6, 7)
  - [ ] **Prerequisite:** Story 1.11 Settings Management API must be completed
  - [ ] Verify/Add fields to `users` table via migration:
    - Check if `detection_mode` field exists in `users` table
    - If missing, create migration: `supabase/migrations/YYYYMMDD_add_detection_settings.sql`
    - Add fields:
      - `detection_mode TEXT DEFAULT 'autopilot' CHECK (detection_mode IN ('autopilot', 'semi_auto'))`
      - `daily_prospect_count INTEGER DEFAULT 20 CHECK (daily_prospect_count >= 1 AND daily_prospect_count <= 40)`
      - `detection_time TEXT DEFAULT '06:00'` (format: 'HH:MM' in UTC)
  - [ ] Update SettingsService (Story 1.11):
    - Add method: `getDetectionSettings(userId)` - Query `users` table for detection fields
    - Add method: `saveDetectionSettings(userId, settings)` - Update detection fields
    - Validation: `daily_prospect_count` between 1-40, `detection_time` valid format
  - [ ] Add API endpoints (if not in Story 1.11):
    - `GET /settings/detection`:
      - Query: `SELECT detection_mode, daily_prospect_count, detection_time FROM users WHERE id = $userId`
      - Return: `{ success: true, data: { detection_mode, daily_prospect_count, detection_time } }`
    - `POST /settings/detection`:
      - Request body: `{ detection_mode?: 'autopilot' | 'semi_auto', daily_prospect_count?: number, detection_time?: string }`
      - Validate: `daily_prospect_count` 1-40, `detection_time` format 'HH:MM'
      - Update: `UPDATE users SET detection_mode = $mode, daily_prospect_count = $count, detection_time = $time WHERE id = $userId`
      - Return: `{ success: true, data: DetectionSettings }`

- [ ] **Task 4: Implement prospect validation queue** (AC: 7, 8, 9)
  - [ ] Create migration for `prospect_validation_queue` table:
    - Migration file: `supabase/migrations/YYYYMMDD_create_prospect_validation_queue.sql`
    - Table schema:
      ```sql
      CREATE TABLE public.prospect_validation_queue (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        prospect_id UUID NOT NULL REFERENCES public.prospects(id) ON DELETE CASCADE,
        user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
        status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),
        created_at TIMESTAMPTZ DEFAULT NOW(),
        validated_at TIMESTAMPTZ,
        validated_by UUID REFERENCES public.users(id)
      );
      ```
    - Add indexes:
      - `CREATE INDEX idx_validation_queue_user ON prospect_validation_queue(user_id)`
      - `CREATE INDEX idx_validation_queue_status ON prospect_validation_queue(status)`
      - `CREATE INDEX idx_validation_queue_prospect ON prospect_validation_queue(prospect_id)`
  - [ ] Add RLS policies:
    - `CREATE POLICY "Users can only access their own validation queue" ON prospect_validation_queue FOR ALL USING (auth.uid() = user_id)`
  - [ ] Create `apps/api/src/services/ValidationQueueService.ts`:
    - Implement `addToQueue(prospectId, userId)`:
      - Input: `prospectId: string, userId: string`
      - Query: `INSERT INTO prospect_validation_queue (prospect_id, user_id, status) VALUES ($prospectId, $userId, 'pending') ON CONFLICT DO NOTHING`
      - Return: `{ queue_id: string }`
    - Implement `approve(prospectId, userId)`:
      - Input: `prospectId: string, userId: string`
      - Update queue: `UPDATE prospect_validation_queue SET status = 'approved', validated_at = NOW(), validated_by = $userId WHERE prospect_id = $prospectId AND user_id = $userId`
      - Update prospect: `UPDATE prospects SET status = 'new' WHERE id = $prospectId`
      - **Trigger warm-up:** Call `WarmupService.startWarmup(prospectId, userId)` (Story 1.9)
      - Return: `{ success: true, warmup_started: true }`
    - Implement `reject(prospectId, userId)`:
      - Input: `prospectId: string, userId: string`
      - Update queue: `UPDATE prospect_validation_queue SET status = 'rejected', validated_at = NOW(), validated_by = $userId WHERE prospect_id = $prospectId AND user_id = $userId`
      - Update prospect: `UPDATE prospects SET status = 'rejected' WHERE id = $prospectId`
      - Return: `{ success: true }`
    - Implement `getPendingQueue(userId, limit = 50)`:
      - Query: `SELECT * FROM prospect_validation_queue WHERE user_id = $userId AND status = 'pending' ORDER BY created_at DESC LIMIT $limit`
      - JOIN with prospects table to include prospect data
      - Return: `ValidationQueueItem[]`
  - [ ] Create API endpoints:
    - `GET /validation-queue`:
      - Query params: `?status=pending&limit=50`
      - Call: `ValidationQueueService.getPendingQueue(userId, limit)`
      - Return: `{ success: true, data: ValidationQueueItem[] }`
    - `POST /validation-queue/:id/approve`:
      - Request params: `{ id: string }` (prospect_id or queue_id)
      - Call: `ValidationQueueService.approve(prospectId, userId)`
      - Return: `{ success: true, data: { warmup_started: boolean } }`
    - `POST /validation-queue/:id/reject`:
      - Request params: `{ id: string }`
      - Call: `ValidationQueueService.reject(prospectId, userId)`
      - Return: `{ success: true }`
    - Add authentication middleware (verify JWT token)
    - Add Zod validation schemas

- [ ] **Task 5: Integrate with UniPil API for LinkedIn search** (AC: 2, 3)
  - [ ] **Prerequisite:** Story 1.2.1 UniPilService must be available
  - [ ] Add UniPil API integration node in N8N workflow:
    - Use HTTP Request node or call API Gateway endpoint that uses UniPilService
    - **Option 1:** Direct HTTP Request to UniPil API:
      - Endpoint: `POST {{ $env.UNIPIL_API_URL }}/api/v1/linkedin/search`
      - Headers: `Authorization: Bearer {{ $env.UNIPIL_API_KEY }}`
      - Request body: Map ICP criteria to UniPil format
    - **Option 2:** Call API Gateway endpoint (recommended):
      - Endpoint: `POST {{ $env.API_GATEWAY_URL }}/api/unipil/search`
      - Headers: `Authorization: Bearer {{ $env.API_GATEWAY_TOKEN }}`
      - Request body: `{ icp_criteria: {...}, limit: 20 }`
  - [ ] Configure LinkedIn profile search endpoint with ICP criteria:
    - Parse `users.icp_criteria` JSONB:
      - Structure: `{ industry: string[], job_titles: string[], company_size: string, location: string }`
      - Map to UniPil API format:
        ```json
        {
          "industry": icp_criteria.industry,
          "job_titles": icp_criteria.job_titles,
          "company_size": icp_criteria.company_size,
          "location": icp_criteria.location,
          "limit": daily_prospect_count
        }
        ```
  - [ ] Map UniPil response to prospect data structure:
    - Extract from UniPil response:
      - `full_name` = `response.full_name` or `${response.first_name} ${response.last_name}`
      - `job_title` = `response.job_title` or `response.title`
      - `company_name` = `response.company_name` or `response.company`
      - `linkedin_url` = `response.linkedin_url` or `response.profile_url`
      - `location` = `response.location`
      - `profile_summary` = `response.profile_summary` or `response.summary` or `response.bio`
      - `profile_picture_url` = `response.profile_picture_url` (optional, store in enrichment)
  - [ ] Handle UniPil API rate limits:
    - Check Redis counter: `GET unipil_searches:{user_id}:{YYYY-MM-DD}`
    - If count >= `daily_prospect_count`: Skip detection for this user (log warning)
    - Increment after successful search: `INCR unipil_searches:{user_id}:{YYYY-MM-DD}`
    - Set TTL: 24 hours
  - [ ] Add error handling and retry logic:
    - Retry transient failures (network errors, rate limits) with exponential backoff (1s, 2s, 4s)
    - Max 3 retries for transient errors
    - Don't retry permanent failures (invalid API key, invalid ICP criteria)
    - Log errors to audit_log: `event_type = 'detection_failed', error_message = ...`
    - Notify user if detection fails for their account

- [ ] **Task 6: Create notification system for daily prospects** (AC: 9)
  - [ ] **Prerequisite:** Story 1.5.1 SMTPService must be available
  - [ ] Create `apps/api/src/services/NotificationService.ts`:
    - Implement `sendDailyProspectNotification(userId, prospectCount, prospectList, mode)`:
      - Input: `userId: string, prospectCount: number, prospectList: Prospect[], mode: 'autopilot' | 'semi_auto'`
      - Query user: `SELECT email, full_name, notification_preferences FROM users WHERE id = $userId`
      - Check notification preferences: `notification_preferences.email` and `notification_preferences.in_app`
  - [ ] For semi-auto mode - Email notification:
    - Subject: `"${prospectCount} new prospects detected - Review required"`
    - Body: Include prospect list with:
      - Prospect name, company, job title, LinkedIn URL
      - Approve/Reject buttons (links to web app: `/validation-queue/:id/approve` and `/validation-queue/:id/reject`)
      - Or include API endpoint links for programmatic approval
    - Send via SMTPService: `SMTPService.sendEmail({ to: user.email, subject, html })`
  - [ ] For autopilot mode - Email notification:
    - Subject: `"${prospectCount} new prospects added to your pipeline"`
    - Body: Confirmation message that prospects were automatically added and warm-up started
    - Include link to view prospects in dashboard
    - Send via SMTPService
  - [ ] For in-app notifications (future enhancement):
    - Store in `notifications` table (if exists) or `audit_log` table
    - Query: `INSERT INTO audit_log (user_id, event_type, event_data) VALUES ($userId, 'daily_prospects_detected', $prospect_data::jsonb)`
    - Frontend can query these notifications for activity stream
  - [ ] Add notification preferences check:
    - Only send email if `notification_preferences.email = true`
    - Only create in-app notification if `notification_preferences.in_app = true`
    - Respect user's notification preferences from `users.notification_preferences` JSONB

- [ ] **Task 7: Integrate with warm-up workflow** (AC: 6, 8)
  - [ ] **Prerequisite:** Story 1.9 WarmupService must be available
  - [ ] For autopilot mode - After prospect detection:
    - In N8N workflow, after storing prospects with `status = 'new'`:
      - For each prospect, call `WarmupService.startWarmup(prospectId, userId)`
      - Or trigger N8N webhook: `POST {{ $env.N8N_WEBHOOK_URL }}/webhooks/warmup/start`
      - Request body: `{ prospect_id: string, user_id: string }`
    - Update prospect status:
      - Query: `UPDATE prospects SET status = 'warmup_in_progress' WHERE id = $prospect_id`
    - Create entry in `linkedin_warmup_schedule` table (handled by WarmupService)
  - [ ] For semi-auto mode - After prospect approval:
    - When user approves prospect via `ValidationQueueService.approve()`:
      - Call `WarmupService.startWarmup(prospectId, userId)` (already in Task 4)
      - Update prospect status: `UPDATE prospects SET status = 'warmup_in_progress'`
      - Create entry in `linkedin_warmup_schedule` table (handled by WarmupService)
  - [ ] Error handling:
    - If warm-up start fails, log error to audit_log
    - Don't update prospect status if warm-up fails
    - Notify user if warm-up fails for multiple prospects

- [ ] **Task 8: Create API endpoint to manually trigger detection** (AC: 1)
  - [ ] Create route: `apps/api/src/routes/prospects.ts` (if not exists) or add to existing route
  - [ ] Add POST endpoint: `/prospects/trigger-detection`:
    - Request: No body required (uses authenticated user)
    - Authentication: Verify JWT token via `authMiddleware`
    - Rate limiting check:
      - Redis key: `manual_detection:{user_id}:{YYYY-MM-DD}`
      - Check: `GET manual_detection:{user_id}:{YYYY-MM-DD}`
      - If exists: Return `429 Too Many Requests` with message "Only 1 manual trigger per day allowed"
      - If not exists: Set counter: `SET manual_detection:{user_id}:{YYYY-MM-DD} 1 EX 86400`
    - Trigger N8N workflow:
      - Call: `POST {{ $env.N8N_WEBHOOK_URL }}/webhooks/daily-detection/manual`
      - Headers: `Authorization: Bearer {{ $env.N8N_WEBHOOK_TOKEN }}`
      - Request body: `{ user_id: string, triggered_by: 'manual' }`
    - Return: `{ success: true, message: "Detection triggered successfully" }`
  - [ ] Add error handling:
    - If N8N webhook fails: Return 500 error
    - Log error to audit_log
    - Return user-friendly error message

- [ ] **Task 9: Generate TypeScript types for detection tables** (AC: 8, 10)
  - [ ] Run `supabase gen types typescript` after migration
  - [ ] Update `packages/shared/src/types/database.types.ts` with validation queue table types
  - [ ] Create business logic types: `packages/shared/src/types/prospect-detection.ts`
  - [ ] Export DetectionMode, ProspectValidation types for use in API and frontend

- [ ] **Task 10: Write unit tests for detection logic** (AC: All)
  - [ ] Create test: `apps/api/tests/unit/services/exclusion.service.test.ts` (ExclusionService)
  - [ ] Create test: `apps/api/tests/unit/services/validation-queue.service.test.ts` (ValidationQueueService)
  - [ ] Create test: `apps/api/tests/unit/routes/prospects.test.ts` (API endpoints)
  - [ ] Test exclusion logic (contacted prospects, warm-up prospects, connection prospects)
  - [ ] Test prospect count limit (20 default, max 40)
  - [ ] Test autopilot vs semi-auto mode behavior
  - [ ] Test validation queue workflow

## Dev Notes

### Architecture Context

**UniPil API Integration:**
- Use UniPil API for LinkedIn profile search based on ICP criteria
- Rate limits: 20 prospects/day (configurable to 40)
- Search parameters: industry, location, job_title, company_size from ICP config
- API documentation: Refer to UniPil API docs for LinkedIn search endpoints
- Cost: 5€/compte LinkedIn (already configured in Story 1.1)

**N8N Workflow Structure:**
- Daily detection scheduler: Runs at 6 AM (configurable per user)
- User loop: Process each active user sequentially
- Exclusion logic: Query multiple tables to exclude already contacted prospects
- Prospect storage: Insert into `prospects` table with appropriate status

**Database Schema:**
- `prospect_validation_queue`: Tracks prospects pending user validation (semi-auto mode)
- `prospects`: Extended with `status` field values: 'new', 'pending_validation', 'warmup_in_progress', 'contacted', etc.
- Foreign keys: `prospect_id` → `prospects.id`, `user_id` → `auth.users.id`

**User Modes:**
- **Autopilot**: Prospects automatically added and warm-up starts immediately
- **Semi-auto**: Prospects queued for user validation before warm-up starts
- Mode configurable per user in settings (Story 1.11)

**Previous Story Insights:**
From Story 1.2.1: UniPilService available at `apps/api/src/services/UniPilService.ts`. UniPil API Base URL: `https://api.unipil.io`. Authentication: `Authorization: Bearer {UNIPIL_API_KEY}`. Rate limits: 20 prospects/day (configurable to 40/day). Endpoint for search: `POST /api/v1/linkedin/search` (confirm exact endpoint).

From Story 1.2: LinkedIn scraping workflow ready. Prospects stored in `prospects` table with fields: `full_name`, `job_title`, `company_name`, `linkedin_url`, `location`, `profile_summary`, `status`, `source`. Status values: 'new', 'pending_validation', 'warmup_in_progress', 'contacted', 'engaged', 'qualified', 'booked', 'rejected'.

From Story 1.9: WarmupService available at `apps/api/src/services/WarmupService.ts` with `startWarmup(prospectId, userId)` method. Warm-up schedule table `linkedin_warmup_schedule` tracks warm-up timeline. Connection trigger workflow sends connection requests after warm-up completion.

From Story 1.11: SettingsService available for managing user settings. ICP configuration stored in `users.icp_criteria` JSONB field. Structure: `{ industry: string[], job_titles: string[], company_size: string, location: string }`.

From Story 1.5.1: SMTPService available for sending email notifications.

**Integration Points:**
- Story 1.11 (Settings): ICP + Persona configuration stored in `users.icp_criteria` JSONB, detection mode settings in `users.detection_mode`, `users.daily_prospect_count`, `users.detection_time`
- Story 1.9 (Warm-up): Automatically starts warm-up after detection (autopilot) or approval (semi-auto) via `WarmupService.startWarmup()`
- Story 1.5.1 (SMTP): Email notifications sent via SMTPService
- Epic 5 (Dashboard): Display daily prospect list and validation queue

### Testing

**Testing Framework:** Vitest for unit tests, manual testing for N8N workflows

**Test Organization:**
- Service tests: `apps/api/tests/unit/services/exclusion.service.test.ts`
- Route tests: `apps/api/tests/unit/routes/prospects.test.ts`
- Integration tests: N8N workflow testing via manual execution

**Test Requirements:**
1. Test exclusion logic (multiple tables):
   - Test exclusion of contacted prospects (status IN contacted, engaged, qualified, booked)
   - Test exclusion of prospects in warm-up schedule
   - Test exclusion of prospects with connection requests (if table exists)
   - Test combining exclusions from multiple sources (no duplicates)
   - Test Redis caching for exclusion list (24h TTL)
2. Test prospect count limits:
   - Test default limit: 20 prospects/day
   - Test configurable limit: User sets `daily_prospect_count = 30`
   - Test maximum limit: Cannot exceed 40 prospects/day
   - Test validation: Reject invalid limits (<1 or >40)
3. Test autopilot vs semi-auto mode:
   - Test autopilot: Prospects stored with `status = 'new'`, warm-up starts automatically
   - Test semi-auto: Prospects stored with `status = 'pending_validation'`, added to validation queue
   - Test approval flow: Approve prospect → status changes to 'new', warm-up starts
   - Test rejection flow: Reject prospect → status changes to 'rejected', no warm-up
4. Test validation queue workflow:
   - Test adding prospect to queue (semi-auto mode)
   - Test approving prospect (triggers warm-up)
   - Test rejecting prospect (no warm-up)
   - Test queue retrieval (GET /validation-queue)
   - Test filtering by status
5. Test daily schedule execution:
   - Test N8N workflow trigger at 6 AM (or user-configured time)
   - Test processing multiple users sequentially
   - Test ICP criteria parsing from JSONB
   - Test UniPil API integration with ICP criteria
   - Test prospect storage with correct status
6. Test UniPil API integration:
   - Test LinkedIn search with ICP criteria
   - Test response mapping to prospect data structure
   - Test rate limiting (max searches per day)
   - Test error handling and retry logic
7. Test notification system:
   - Test email notification for autopilot mode
   - Test email notification for semi-auto mode (with approve/reject links)
   - Test notification preferences (respect user settings)
   - Test error handling if email sending fails
8. Test manual trigger endpoint:
   - Test POST /prospects/trigger-detection with authentication
   - Test rate limiting (max 1 trigger per day)
   - Test N8N webhook trigger
   - Test error handling if N8N webhook fails

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-11 | 1.0 | Initial story creation for "No Spray No Pray" pivot | Dev Agent |
| 2025-01-11 | 1.1 | Story refinement: Added explicit dependencies, corrected database schema references (users.icp_criteria JSONB), detailed UniPil API integration, enhanced exclusion logic, improved validation queue, detailed notification system, comprehensive test scenarios | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
TBD

### Completion Notes
- Story created as part of "No Spray No Pray" pivot
- Replaces original Epic 1 workflow with daily detection approach
- Integrates with UniPil API for LinkedIn profile search
- Supports both autopilot and semi-auto modes for user flexibility

